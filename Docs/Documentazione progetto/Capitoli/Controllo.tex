\section{Introduzione}
Per rendere maggiormente leggibile il codice Matlab e, allo stesso tempo, ridurre i tempi necessari per l'esecuzione, abbiamo deciso di dividere le varie funzionalità in diversi \textit{livescript}: in particolar modo la parte relativa allo studio ed alla definizione del controllore, siamo andati ad inserirla all'interno del file \textit{GainCalculator.mlx} dove si può vedere che. come prima istruzione, si va a caricare dal workspace, risultante dalla linearizzazione, le matrici A-B-C-D che definiscono il sistema lineare modellizzato.

\section{Analisi in anello aperto}
\label{sec:open_loop_analysis}
Prima di procedere con l'individuazione del controllore più adatto per stabilizzare il V.A.B., siamo andati ad effettuare una breve analisi sul sistema ad anello aperto, per ottenere così alcuni spunti sulla correttezza del modello che era stato steso fino a quel punto.

Come noto dalla teoria, il sistema risulta essere asintoticamente stabile se gli autovalori della matrice A risultano avere tutti parte reale negativa; è instabile invece se è presente almeno un autovalore con parte reale strettamente positiva.

Abbiamo quindi calcolato gli autovalori con il comando seguente:
\begin{lstlisting} [caption={Calcolo autovalori matrice A (non simbolica)},captionpos=b]
eig(A_real)
\end{lstlisting}

La presenza di autovalori con parte reale strettamente negativa è stata confermata anche dalla visualizzazione del luogo delle radici (\textit{rlocus}) del sistema in anello aperto: come si vede in figura ~\ref{fig:r_locus_openloop}, il polo che si trova nel semi-piano reale positivo non potrà, in alcun modo, essere stabilizzato, ovvero portato nel semi-piano sinistro.

Questa breve analisi ci ha permesso di avere una conferma numerica del fatto ovvio che, senza un controllo, il V.A.B. in esame non riesce a mantenere da solo la posizione verticale.

\begin{figure}[H]
	\centering   	
	\includegraphics[width=0.5\textwidth]{Immagini/root_locus_open_loop.png}
	\caption{Luogo delle radici del V.A.B. modellizzato in anello aperto}
	\label{fig:r_locus_openloop}
\end{figure}

\section{Controllore}
Per quanto riguarda il sistema del veicolo autobilanciato, siamo andati a far riferimento a quella classe di problemi definiti come \textit{problemi di regolazione}, in cui il sistema si presenta inizialmente con una condizione iniziale dello stato non nulla, condizione che si intende di riportare a zero con una velocità di convergenza assegnata.

Nello specifico, questo tipo di problema relativo alla scelta del controllore, è stato risolto mediante l'utilizzo dell'assegnazione degli autovalori ottenuti tramite retroazione dello stato, in cui il moto del sistema è composto completamente dal moto libero che si vuole controllare e annullare in un tempo a piacere.

Il posizionamento dei poli, e quindi la scelta del guadagno del regolatore, va eseguita sul solo sistema lineare: questo a conferma sia di quanto riportato in figura ~\ref{fig:feedback_state} (nel blocco di colore blu infatti è riportato il sistema lineare), sia di quanto detto in precedenza in merito al fatto che il controllore venga ad essere definito lavorando sul sistema linearizzato.

\begin{figure}[H]
	\centering   	
	\includegraphics[width=0.70\textwidth]{Immagini/feedback_state.png}
	\caption{Schema concettuale del controllo (\cite{feedback_state})}
	\label{fig:feedback_state}
\end{figure}

Ciò che è riportato graficamente in figura \ref{fig:feedback_state}, può essere riscritto matematicamente come segue:
\begin{center}
	$
	\begin{cases}
	\begin{array}{c}
	\dot{x}\left(t\right)=Ax{\left(t\right)}+Bu\left(t\right)\\
	y{\left(t\right)}=Cx{\left(t\right)}+Du\left(t\right)
	\end{array}
	\end{cases}
	$
	$$
	u{\left(t\right)}=-Kx{\left(t\right)}+w{\left(t\right)}	= \text{ legge di controllo}
	$$
\end{center}

\newpage
Dunque, sostituendo la legge di controllo nell'equazione di stato del sistema, possiamo ottenere le seguenti equazioni che ci permettono di definire il legame del sistema in anello chiuso con la matrice K:
\begin{center}
	$
	x{\left(t\right)}=Ax{\left(t\right)}+Bu{\left(t\right)}=Ax{\left(t\right)}+B{\left(-Kx{\left(t\right)}+w{\left(t\right)}\right)}
	$
	$$
	=Ax{\left(t\right)}-BKx{\left(t\right)}+Bw\left(t\right)={\left(A-BK\right)}x{\left(t\right)}+Bw{\left(t\right)}
	$$
	$$
	A_{cl} =A-BK = \text{ matrice di stato in anello chiuso (cl $\rightarrow$ closed loop)}
	$$
\end{center}

\subsection{Posizionamento dei poli continui}
Per scegliere il valore da assegnare a K, e quindi definire il guadagno del controllore, è necessario scegliere la posizione desiderata dei poli, in base a quelle che sono le specifiche di velocità desiderate.

\begin{center}
	$
	G{\left(S\right)}=\frac{\omega {\;}_n^{2\;} }{s^2 +2\xi \omega {\;}_n s+\omega {\;}_n^{2\;} }
	$
\end{center}

\begin{center}
	$
	\xi =0\ldotp 7
	$
	$$
	\omega {\;}_{n\;}=2 \pi f_{\mathrm{propria}}
	$$
\end{center}

Dovendo posizionare due coppie di poli complessi coniugati si sono scelte due frequenze ad una decade di distanza, in maniera tale da poter considerare le variabili che sono controllate disaccoppiate in frequenza: essendo il limite di banda (ovvero entro quali limiti il segnale passa senza essere attenuato e/o modificato) del sistema interno molto più alto del limite di banda del sistema esterno, possiamo considerarli disaccoppiati in frequenza.

\begin{center}
	$
	f_{\mathrm{propria\theta}} =  0.2 \text{ Hz}
	$
	$$
	f_{\mathrm{propria\phi}} =  0.02 \text{ Hz}
	$$
\end{center}

TODO
Nello specifico, una prima osservazione, è il fatto che il polo più veloce (ovvero quello con frequenza pari a 0.2 Hz) è stato assegnato alla parte relativa al controllo dell'angolo $\theta$, essendo che è auspicabile un controllo maggiormente reattivo per quanto riguarda la stabilizzazione della base, piuttosto che il rapido raggiungimento del set point di posizione spaziale (e quindi angolare $\phi$ delle ruote).

Una seconda osservazione è che, motivi esterni, il motore risulta avere una coppia massima molto limitata (per via delle limitazioni di corrente): è stato dunque necessario posizionare i poli ad una frequenza tale che permettesso di non saturare per molto tempo la coppia fornita dal motore.
Questa scelta ha inevitabilmente rallentato la risposta del sistema.

Definita quindi la frequenza a cui posizionare i poli, siamo andati a risolvere l'equazione al denominatore della forma generica della f.d.t (G(s)) con due poli complessi: la risoluzione di questa equazione, come è noto dalla teoria, permette di ottenere i valori della variabile di Laplace \textit{s} che azzerano il denominatore stesso, che corrisponde a risolvere questa equazione (in forma generica):

\begin{center}
	$s^2 +2\,\mathrm{\xi}\,s\,{{w_n}} +{{{w_n}}}^2 =0$
\end{center}

Nella nostra simulazione i valori numerici ottenuti per i poli sono stati i seguenti:
\begin{center}
	$
	polo_{\theta} = \left(\begin{array}{c}
	-\frac{7\,\pi }{250}+\frac{\pi \,\sqrt{51}\,\mathrm{i}}{250}\\
	-\frac{7\,\pi }{250}-\frac{\pi \,\sqrt{51}\,\mathrm{i}}{250}
	\end{array}\right)
	$
	$$
	polo_{\phi} = \left(\begin{array}{c}
	-\frac{7\,\pi }{25}+\frac{\pi \,\sqrt{51}\,\mathrm{i}}{25}\\
	-\frac{7\,\pi }{25}-\frac{\pi \,\sqrt{51}\,\mathrm{i}}{25}
	\end{array}\right)
	$$
\end{center}	

Con il comando \textit{place} di Matlab si ottiene dunque:
\begin{center}
	
	$	K =[  -0.0023  , -0.0278, -28.1397  , -7.7022]$
	
\end{center}

Ricordando a questo punto quanto detto nella prima parte di questo capitolo in merito alla definizione della matrice A in anello chiuso, siamo andati a definirla appunto come

\begin{center}
	$
	A_{cl} =A-BK
	$
\end{center}

utilizzando il valore di K appena trovato: una volta trovata la nuova matrice A, siamo andati a ri-effettuare le stesse analisi portate avanti anche per il sistema in anello aperto.
Come si vede in figura ~\ref{fig:closed_loop_root}, grazie al posizionamento degli autovalori, siamo stati in grado di spostare i nuovi poli nel semi-piano sinistro: questo significa quindi che siamo riusciti a stabilizzare il nostro sistema dinamico.
\begin{figure}[H]
	\centering   	
	\includegraphics[width=0.7\textwidth]{Immagini/root_locus_closed_loop.png}
	\caption{Root locus del sistema in anello chiuso}
	\label{fig:closed_loop_root}
\end{figure}

\subsection{Posizionamento dei poli discreti}
TODO

Nello sviluppo del sistema, come presenteremo poi nella sezione di simulazioni (sezione TODO), siamo andati anche ad inserire il passaggio a tempo discreto, a seconda di quelle che sono le specifiche temporali di campionamento del controllore.

Nel definire quindi un controllo a tempo discreto è stato necessario anche andare a riportare il posizionamento dei poli in ambito discreto.
\subsection{Setpoint di velocità}
Oltre al controllo del moto libero del sistema è stata implementata anche la possibilità di inserire un setpoint sulla velocità a fine transitorio del Segway. In questo modo si apre la possibilità per l'utente finale di impostare la velocità desiderata e di mantenerla nel tempo nonostante i vari disturbi che in un sistema reale influiranno sulla macchina(vento, salita, discesa..) 
\begin{figure}[H]
	\centering   	
	\includegraphics[width=0.75\textwidth]{Immagini/y_setpoint.png}
	\caption{chiusura dell'anello di controllo di $\dot{\phi}$ con un controllore \textit{I} \cite{feedback_state}}
	\label{fig:y_setpoint}
\end{figure}
In Fig.\ref{fig:y_setpoint} si nota come l'anello di $\dot{\phi}$ sia esterno rispetto all'anello di retroazione dello stato; solitamente si procede dunque nel progettare il controllore avendo cura di lasciare una decade di spazio tra la frequenza del polo dell' integratore e la coppia di poli più lenta del controllore della retroazione dello stato.
In questo caso, per ragioni puramente pratiche, non è stato possibile : il sistema presenta una risposta particolarmente lenta agli input viste le limitazioni di coppia di cui si approfondirà successivamente; sarebbe quindi stato necessario quindi troppo tempo per raggiungere il setpoint di velocità se si fosse proceduto a lasciare una decade di distanza. Si è invece proceduto a posizionare il polo dell'integratore tramite la funzione di Tuning offerta da Matlab Simulink stesso:
\begin{figure}[H]
	\centering   	
	\includegraphics[width=0.75\textwidth]{Immagini/pid_tuning.png}
	\caption{Taratura del controllore}
	\label{fig:pid_tuning}
\end{figure}
Il tuning è stato effettuato sul sistema lineare in quanto Matlab richiede un sistema lineare per questo tipo di tecniche. Da notare inoltre, in Fig.\ref{fig:pid_tuning} che la frequenza $f_3 = \dfrac{0.041 \textit{rad/s}}{2\pi} = 0.0065 Hz$ che è circa $\dfrac{1}{3} 	f_{\mathrm{propria\phi}}$.
Sempre in Fig.\ref{fig:pid_tuning} si osserva come comunque, non avendo rispettato la decade di distanza, il sistema sia comunque molto lento e arrivi a regime in circa 70 \textit{s}.
TODO: perchè arriva a 0.5? per la retroazione interna?
\section{OPC - UA}
Per quanto riguarda la parte di controllo, il sistema presenta un articolato insieme di controllori inter-operanti tra di loro: nello specifico ad ogni singolo controllore sono affidate delle mansioni ben specifiche, tutte ovviamente volte al controllo e alla stabilizzazione del \textit{veicolo auto bilanciato}.

In questa fase dello sviluppo del progetto, siamo andati ad implementare parte del codice che verrà installato, in un secondo momento, a bordo del raspberry: esso infatti svolge, all'interno del sistema (come si vede in figura ~\ref{fig:OPCUA_schema}) una comunicazione a due direzioni, che ne determinano due comportamenti differenti:
\begin{itemize}
	\item Come \textbf{server} per la parte di comunicazione \textit{OPC-UA} (per il settaggio dei guadagni);
	\item Come \textbf{master} nella comunicazione seriale verso Arduino (per quanto riguarda invece la gestione dell'algoritmo di controllo);
\end{itemize}

 \begin{figure}[H]
	\centering   	
	\includegraphics[width=0.75\textwidth]{Immagini/OPCUA_schema.png}
	\caption{Schema di massima dell'utilizzo di Raspberry Pi 3}
	\label{fig:OPCUA_schema}
\end{figure}

In questa fase abbiamo quindi sviluppato la parte relativa all'utilizzo di \textit{Raspberry Pi 3} come \textit{server OPCUA}.

\subsection{Idea base OPC-UA}
L'\textit{Open Platform Communications Unified Architecture} (OPC UA) è un protocollo di comunicazione automatico per l'automazione industriale. 

OPC UA sostituisce il protocollo \textit{OPC Classic}, conservando tutte le funzionalità del predecessore. Poiché OPC Classic era stato costruito su una tecnologia Microsoft detta modello a oggetti per componenti distribuiti, era vincolato a Microsoft, ma questa caratteristica è diventata sempre più limitante.

OPC UA risulta completamente interoperabile tra i diversi sistemi operativi usati, aggiungendosi a Windows e alle tecnologie industriali come i PLC, inoltre comprende Linux, iOS e anche sistemi operativi per dispositivi mobili come Android. Consentire al maggior numero di dispositivi possibile di comunicare contribuisce al progresso dell'IoT.

Queste caratteristiche di \textbf{interoperabilità} sono state sfruttate al massimo in questo contesto, potendo così creare, in maniera semplice e veloce, una comunicazione tra differenti tipologie e famiglie di dispositivi.

\section{OPC-UA e V.A.B.}
Nel contesto del progetto del \textit{veicolo auto bilanciato}, siamo andati ad utilizzare il protocollo di comunicazione \textit{OPC-UA} come supporto per il tuning dei parametri relativi al \textbf{gain} del controllore, ovvero ai parametri del vettore \textit{K}, che abbiamo chiamato (all'interno dello script di Python):
\begin{itemize}
	\item \textbf{K\_phi}
	\item \textbf{K\_phi\_p}
	\item \textbf{K\_theta}
	\item \textbf{K\_theta\_p}
\end{itemize}

Nello specifico, lo scambio di parametri tra server e controllore avviene tramite unfile \textit{.txt}, che permette, in maniera semplice e immediata, di implementare uno scambio di informazioni tra il server \textit{OPC-UA} strutturato in Python e l'ambiente \textit{real-time} introdotto a bordo del controllore \textit{Raspbery Pi 3}.


In particolare abbiamo due files:
\begin{itemize}
	\item \textbf{Un file temporaneo} \textit{("GainParametersToController.txt")} utilizzato come pipeline per il passaggio dei parametri tra server e controllore. Questo risulta essere un file temporaneo che viene ad essere cancellato e ricreato ogni qualvolta che il server viene spento e successivamente riaccesso.
	Nello specifico, ad ogni riaccensione, i valori iniziali di questo file, vengono settati con gli stessi valori presenti nel file \textit{definitivo}  (qualora quest'ultimo esista già: in caso contrario si procede con un inizializzazione dei parametri a 0);
	
	\item \textbf{Un file definitivo} \textit{("GainParametersConfirmed.txt")} il quale invece viene creato una e una sola volta e sul quale poi vengono salvati i parametri che saranno poi letti all'accensione successiva del server ed utilizzati come parametri iniziali per il controllore.
\end{itemize}

Questi file possono essere settati con i parametri presenti nel server che sono visibili in figura ~\ref{fig:OPCUA_params}, nello specifico:
\begin{itemize}
	\item \textbf{Submit change to controller} permette di scrivere i valori dei gains sul file \textit{"GainParametersToController.txt"};
	
	\item \textbf{Store definitively in file} permette di scrivere i valori dei gains sul file \textit{"GainParametersConfirmed.txt"};
	
	\item \textbf{SHUT DOWN SERVER} permette invece di spegnere il server e di cancellare successivamente il file temporaneo.
\end{itemize}

\begin{figure}[h]
	\centering   	
	\includegraphics[width=0.4\textwidth]{Immagini/OPC_UA_params.jpg}
	\caption{Parametri impostabili lato client}
	\label{fig:OPCUA_params}
\end{figure}


Abbiamo racchiuso in figura ~\ref{fig:OPCUA_diagram} il funzionamento di massima del codice lato server: codice che siamo andati a testare utilizzando un'apposita app per smartphone Android (\href{https://play.google.com/store/apps/details?id=com.prosysopc.ua.android2&hl=it}{OPC-UA Android client}).

\begin{figure}[h]
	\centering   	
	\includegraphics[width=0.7\textwidth]{Immagini/OPCUA_diagram.jpeg}
	\caption{Diagramma rappresentante le funzionalità del server}
	\label{fig:OPCUA_diagram}
\end{figure}

\section{Rumore}
Piattaforma inerziale --> PSD
Questione anti windup --> coppia già limitata quindi nessun vincolo di saturazione